---
title: Second Lesson
author: Data Carpentry contributors
minutes: 45
---


```{r, echo=FALSE, purl=FALSE, message = FALSE}
source("setup.R")
```


```{r load-tidyverse-package, message=FALSE, purl=FALSE}
library(tidyverse)
```


```{r load-ratdat-package,message=FALSE, purl=TRUE}
library(ratdat)
surveys <- left_join(left_join(surveys, species), plots) %>% 
  mutate(across(where(is.factor), as.character))
```   

We just spent quite a bit of time learning how to create visualizations from the `surveys` data, but we did not talk much about **what** this `surveys` thing is. The `surveys` data is stored in R as a `data.frame`, which is the most common way that R represents tabular data (data that can be stored in a table format). We can check what `surveys` is by using the `class()` function:

```{r class}
class(surveys)
```

We can view the first few rows with the `head()` functions:

```{r head}
head(surveys)
```

We used these functions with just one argument, the object `surveys`, and we didn't give the argument a name, like we did with `ggplot2`. In R, a function's arguments come in a particular order, and if you put them in the correct order, you don't need to name them. In this case, the name of the argument is `x`, so we can name it if we want, but since we know it's the first argument, we don't need to.

To learn more about a function, you can type a `?` in front of the name of the function, which will bring up the official documentation for that function:

```{r, head-help}
?head
```

Some arguments are optional. For example, the `n` argument in `head()` specifies the number of rows to print. It defaults to 6, but we can override that by specifying a different number:

```{r head-n}
head(surveys, n = 10)
```

If we order them correctly, we don't have to name either:

```{r head-n-noname}
head(surveys, 10)
```

Additionally, if we name them, we can put them in any order we want:

```{r head-reverse}
head(n = 10, x = surveys)
```

Generally, it's good practice to start with the required arguments, like the dataframe whose rows you want to see, and then to name the optional arguments. If you are ever unsure, it never hurts to explicitly name an argument.

Let's get back to investigating our `surveys` dataframe. We can get some useful summaries of each variable using the `summary()` function:

```{r}
summary(surveys)
```

And, as we have already done, we can use `str()` to look at the structure of an object:

```{r}
str(surveys)
```

We get quite a bit of useful information here. First, we are told that we have a `data.frame` of `r nrow(surveys)` observations, or rows, and 13 variables, or columns.

Next, we get a bit of information on each variable, including its type (`int` or `chr`) and a quick peek at the first 10 values. You might ask why there is a `$` in front of each variable. This is because the `$` is an operator that allows us to select individual columns from a dataframe. 

The `$` operator also allows you to use tab-completion to quickly select which variable you want from a given dataframe. For example, to get the `year` variable, we can type `surveys$` and then hit <kbd>Tab</kbd>. We get a list of the variables that we can move through with up and down arrows. Hit <kbd>Enter</kbd> when you reach `year`, which should finish this code:

```{r dollar-subsetting}
surveys$year
```

What we get back is a whole bunch of numbers, the entries in the `year` column printed out in order. You might notice that it looks different from when we printed out the `surveys` dataframe itself. That's because it is not a dataframe, it is a **vector**. A vector is a 1-dimensional series of values, in this case a vector of numbers representing years.

Dataframes are made up of vectors; each column in a dataframe is a vector. Vectors are the basic building blocks of all data in R. Basically, everything in R is a vector, a bunch of vectors stitched together, or a function. Understanding how vectors work is crucial to understanding how R treats data, so we will spend some time learning about them.

There are 4 main types of vectors (also known as *atomic vectors*):

1. `"character"` for strings of characters, like our `genus` or `sex` columns. Each entry in a character vector is wrapped in quotes.

2. `"integer"` for integers. All the numeric values in `surveys` are integers. You may sometimes see integers represented like `2L` or `20L`. The `L` indicates to R that it is an integer, instead of the next data type, `"numeric"`.

3. `"numeric"`, aka `"double"`, vectors can contain numbers including decimals.

4. `"logical"` for `TRUE` and `FALSE`, which can also be represented as `T` and `F`.

Vectors can only be of a **single type**. Since each column in a dataframe is a vector, this means an accidental character following a number, like `29,` can change the type of the whole vector. Mixing up vector types is one of the most common mistakes in R, and it can be tricky to figure out. It's often very useful to check the types of vectors.

To create a vector from scratch, we can use the `c()` function, putting values inside, separated by commas.

```{r c-vector}
c(1, 2, 5, 12, 4)
```

As you can see, those values get printed out in the console, just like with `surveys$year`. To store this vector so we can continue to work with it, we need to assign it to an object.

```{r assign-vector}
num <- c(1, 2, 5, 12, 4)
```

```{r}
class(num)
typeof(num)
```

```{r}
char <- c("apple", "pear", "grape")
```

```{r}
typeof(char)
```

```{r}
logi <- c(TRUE, FALSE, TRUE, TRUE)
```

```{r}
typeof(logi)
```

```{r}
num_logi <- c(1, 4, 6, TRUE)
num_char <- c(1, 3, "a", 6)
char_logi <- c("a", "b", TRUE)

tricky <- c("a", "b", "1", FALSE)
```

A common use for creating vectors from scratch is in function arguments. The `quantile()` function will calculate a quantile for a given vector of numeric values. We set the quantile using the `probs` argument. We also need to set `na.rm = TRUE`, since there are `NA` values in the `weight` column, and R doesn't know how to calculate a quantile if there are `NA`s. This is a common argument for lots of numeric functions.

```{r single-quantile}
quantile(surveys$weight, probs = 0.25, na.rm = TRUE)
```

Now we get back the 25% quantile value for weights. However, we often want to know more than one quantile. Luckily, the `probs` argument is **vectorized**, meaning it can take a whole vector of values. Let's try getting the 25%, 50% (median), and 75% quantiles all at once.

```{r multi-quantile}
quantile(surveys$weight, probs = c(0.25, 0.5, 0.75), na.rm = TRUE)
```

We have now seen vectors in a few different forms: as columns in a dataframe and as single vectors. However, they can be manipulated into lots of other shapes and forms. Some other common forms are:

- matrices
  - 2-dimensional numeric representations
- arrays
  - many-dimensional numeric
- lists
  - lists are very flexible ways to store vectors
  - a list can contain vectors of many different types and lengths
  - an entry in a list can be another list, so lists can get deeply nested
  - a dataframe is just a list where each vector has to be the same length (dataframes are rectangular)
- factors
  - a way to represent categorical data
  - factors can be ordered or unordered
  - they often *look* like character vectors, but behave differently


#### Factors

We will spend a bit more time talking about factors, since they are often a challenging type of data to work with.

```{r}
sex <- factor(c("male", "female", "female", "male", "female"))
sex
```

```{r}
library(forcats)

lvls_reorder(sex, idx = 2:1, ordered = F)



```


- Vectors can be manipulated into lots of other shapes and forms
  - matrices
  - lists
  - dataframes
  - factors
    - an integer vector + levels defined by characters
    - usually goes from character to factor
    - `forcats`
    - should probably make sure `ratdat` data starts with all character cols as `char`, not as factors, since `stringsAsFactors` default has changed, and starting with characters is almost always best practice
  - should we cover subsetting? *definitely* need to show `%in%`, so perhaps we show that in `filter()` later? 
  - is concept of recycling important?
    - I think this is best reserved for one of the SWC lessons
  - what about conditional subsetting? it's relevant to `filter()`, but I'm not sure it's strictly necessary
- dates/datetimes?
- assignment: x <- 10; y <- x; x <- 5; y
    - is this absolutely necessary to cover? When is this going to become relevant in a typical data workflow? Should this be kept to SWC lessons?

## Functions

### What are they?

## Vectors
